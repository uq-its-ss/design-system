import { Meta, Canvas, Controls, Description, Source } from "@storybook/blocks";
import * as stories from "./UqButton.stories";

<Meta of={stories} />

# {stories.default.component.name}

<Description of={stories} />

## Installation

```bash
npm i @uqds/react
```

## Usage

```js
import { UqButton } from "@uqds/react";
```

<Canvas of={stories.base} />

<Controls of={stories.base} />

<Source of={stories.base} />

{/* This code block converts the icon property from a list of radio buttons
showing icon names, to a grid of images showing the actual icons. */}

<style>{`
  /* Hide the radio buttons for the "icon" control */
  input[type="radio"][name="control-icon"] {
    appearance: none;
  }
  /* Wrap the icon options inside a flexbox so they appear as a grid */
  .iconList {
    display: flex;
    flex-wrap: wrap;
    height: 10lh;
    overflow-y: scroll;
  }
`}</style>
{(() => {
  // When the DOM changes (e.g. when Storybook adds elements for the
  // controls), make some modifications to them.
  const observer = new MutationObserver(() => {
    // Find all radio buttons for the "icon" control.
    const radioButtons = document.querySelectorAll('input[type="radio"][name="control-icon"]');

    // Add the "uq-icon" class to each radio button, along with a class name
    // based on the value of the element (which controls the image shown).
    radioButtons.forEach((radio) => {
      if (!radio.classList.contains("uq-icon")) {
        radio.classList.add("uq-icon");
        if (radio.value) {
          radio.classList.add(`uq-icon--${radio.value}`);
          radio.title = radio.value;
        }
      }

      // Hide the labels, so we only see the icons.
      radio.parentElement.querySelectorAll('span').forEach((span) => {
        span.style.display = 'none';
      });
    });

    // Add a class to the whole options list, so we can use the CSS block
    // above to format it.
    if (radioButtons[0]) {
      radioButtons[0].parentElement.parentElement.classList.add("iconList");
    }
  });

  // Start observing the DOM for changes
  observer.observe(document.body, {
    childList: true, // Watch for added/removed child nodes
    subtree: true,   // Watch the entire subtree
  });
})()}
